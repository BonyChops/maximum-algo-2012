---
layout: post
category: docs
title: 最短経路問題（ベルマンフォード法・ワーシャルフロイド法）
---


最短経路問題
============

ベルマンフォード法とワーシャルフロイド法について解説します。
ダイクストラ法と比べて構造が単純（プライオリティキューがいらない）ので、多少は理解しやすいと思います。

ベルマンフォード法
------------------

ベルマンフォード法は、２点間の最短路を見つけるアルゴリズム。

ダイクストラ法はうまく頂点を選ぶことで効率を上げているが、ベルマンフォード法では全ての辺に対して距離が短くなる経路があるか判定する。

基本的にはダイクストラ法より遅いが、ベルマンフォード法は負の辺があっても正しく動作し、負の閉路を検出することができる（負の閉路があると、その閉路内をずっと回っていれば無限に距離を減らすことができる）。また、距離が確定した頂点を選ぶ操作が不要なので、コードも多少単純化される。

{% highlight cpp %}
{% include shortest-path/bellman-ford.cpp %}
{% endhighlight %}

入力例：

{% highlight yaml %}
{% include shortest-path/bellman-ford.txt %}
{% endhighlight %}

入力例に対応するグラフ：

![グラフ]({{site.baseurl}}images/shortest-path/bellman-ford.png)

出力例：

    0から1へのコスト: 2
    0から2へのコスト: 3
    0から3へのコスト: 7


ワーシャルフロイド法
--------------------

ワーシャルフロイド法は、グラフの全ての頂点の間の最短路を見つけるアルゴリズム。

「3つの頂点a, b, cを選んで、a→b→cという道がa→cという道より短ければa→cの距離を更新する」  
という操作を全ての頂点の組み合わせで繰り返して最短距離を確定させていく。（a→b→cやa→cの道が存在しないときは、距離が無限大の道があると考え、a→aのような道は距離0としておく）



これは単純なforループで実現可能。


{% highlight cpp %}
{% include shortest-path/warshall-floyd.cpp %}
{% endhighlight %}

入力例：

{% highlight yaml %}
{% include shortest-path/warshall-floyd.txt %}
{% endhighlight %}

入力例に対応するグラフ：

![グラフ]({{site.baseurl}}images/shortest-path/warshall-floyd.png)

出力例：

    0から1へのコスト: 10
    0から3へのコスト: 100
    1から0へのコスト: 1005
    1から3へのコスト: 1000
    2から0へのコスト: 1006
    2から1へのコスト: 1
    2から3へのコスト: 1001
    3から0へのコスト: 5
    3から1へのコスト: 15

コードが短いので計算時間に余裕があるなら2点間の最短経路に使ってもいいかも。

ちなみに、ワーシャルフロイド法でも負の辺に対応できる。負の閉路があると、`d[i][i]`が負となる（`d[i][i]`は負閉路がなければ0になっているはず）。


演習
----

- [AIZU ONLINE JUDGE 0189 「Convenient Location」](http://judge.u-aizu.ac.jp/onlinejudge/description.jsp?id=0189&lang=jp)


参考文献
--------

プログラミングコンテストチャレンジブック: 秋葉 拓哉, 岩田 陽一, 北川 宜稔
